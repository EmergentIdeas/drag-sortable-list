{"version":3,"file":"index.js","mappings":"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","sources":["webpack://@webhandle/drag-sortable-list/webpack/bootstrap","webpack://@webhandle/drag-sortable-list/webpack/runtime/define property getters","webpack://@webhandle/drag-sortable-list/webpack/runtime/hasOwnProperty shorthand","webpack://@webhandle/drag-sortable-list/./node_modules/@webhandle/backbone-view/client-js/event-entry-mapper.js","webpack://@webhandle/drag-sortable-list/./node_modules/@webhandle/backbone-view/client-js/view.js","webpack://@webhandle/drag-sortable-list/./node_modules/@webhandle/backbone-view/client-js/generate-id.js","webpack://@webhandle/drag-sortable-list/./node_modules/@webhandle/backbone-view/client-js/extract-event-names.js","webpack://@webhandle/drag-sortable-list/./node_modules/@webhandle/minimal-browser-event-emitter/client-js/streamish.mjs","webpack://@webhandle/drag-sortable-list/./node_modules/@webhandle/minimal-browser-event-emitter/client-js/event-emitter.mjs","webpack://@webhandle/drag-sortable-list/./node_modules/@webhandle/minimal-browser-event-emitter/client-js/index.js","webpack://@webhandle/drag-sortable-list/./client-lib/list-view.mjs","webpack://@webhandle/drag-sortable-list/./client-lib/data-item-worker.mjs"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","export default function eventEntryMapper([key, value]) {\n\tkey = key.trim()\n\tlet parts = key.split(' ')\n\tlet event = parts.shift().trim()\n\tlet selector = parts.join(' ').trim()\n\t\n\tif(typeof value === 'string') {\n\t\tvalue = value.trim()\n\t}\t\n\t\n\treturn {\n\t\tevent: event,\n\t\tselector: selector,\n\t\thandler: value\n\t}\n}","import generateId from \"./generate-id.js\"\n// import pick from \"./pick.js\"\nimport eventEntryMapper from \"./event-entry-mapper.js\"\nimport extractEventNames from \"./extract-event-names.js\"\n\nlet defaultOptions = {\n\t// The default `tagName` of a View's element is `\"div\"`.\n\ttagName: 'div'\n\t\n\t, events: {}\n\n}\nlet viewOptions = ['model', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];\n\n/**\n * A way to connect data to be displayed, a way to display it, and an organization\n * of functions to handle events.\n */\nexport class View {\n\tconstructor(options) {\n\t\tthis.id = generateId()\n\t\tObject.assign(this, defaultOptions)\n\t\tthis.preinitialize.apply(this, arguments);\n\t\tObject.assign(this, options)\n\t\tthis._ensureElement()\n\t\tthis.initialize.apply(this, arguments);\n\t}\n\n\n\t/**\n\t * preinitialize is an empty function by default. You can override it with a function\n\t * or object.  preinitialize will run before any instantiation logic is run in the View\n\t */\n\tpreinitialize() { }\n\n\t/**\n\t * Initialize is an empty function by default. Override it with your own\n\t * initialization logic.\n\t */\n\tinitialize() { }\n\n\t/**\n\t * **render** is the core function that your view should override, in order\n\t * to populate its element (`this.el`), with the appropriate HTML. The\n\t * convention is for **render** to always return `this`.\n\t * @returns this\n\t */\n\trender() {\n\t\treturn this\n\t}\n\t\n\t/**\n\t * Removes the element from the dom. Does not disable event listeners\n\t */\n\tremove() {\n\t\tthis.el.parentElement.removeChild(this.el)\n\t}\n\t\n\t/**\n\t * Adds this view as a child to a containing element. Nothing special is going on here.\n\t * This is just a shortcut for container.appendChild\n\t * @param {Element} container \n\t */\n\tappendTo(container) {\n\t\tcontainer.appendChild(this.el)\n\t}\n\n\t/**\n\t * Clears the contents of the container and adds this view.\n\t * @param {Element} container \n\t */\n\treplaceContentsOf(container) {\n\t\tcontainer.innerHTML = ''\n\t\tthis.appendTo(container)\n\t}\n\n\t/**\n\t * Set the element for this view, and if new, adds listeners to it in accordance\n\t * with the \"events\" member.\n\t * @param {Element} el The dom element which will be the root of this view\n\t * @returns this\n\t */\n\tsetElement(el) {\n\t\tif (this.el !== el) {\n\t\t\tthis.el = el\n\t\t\tthis._addListeners()\n\t\t}\n\t\treturn this\n\t}\n\n\t/**\n\t * Produces a DOM element to be assigned to your view. Exposed for\n\t * subclasses using an alternative DOM manipulation API.\n\t * @param {string} name The element tag name\n\t * @returns The dom element\n\t */\n\t_createElement(name) {\n\t\tlet el = document.createElement(name)\n\t\tel.setAttribute('id', this.id)\n\t\tel.view = this\n\t\treturn el\n\t}\n\n\t/**\n\t * Ensures that the element exists. Applies attributes and className\n\t * to it regardless\n\t */\n\t_ensureElement() {\n\t\tif (!this.el) {\n\t\t\tthis.setElement(this._createElement(this.tagName))\n\t\t}\n\t\telse {\n\t\t\tthis._addListeners()\n\t\t}\n\t\tthis._setAttributes()\n\t\tif (this.className) {\n\t\t\tthis.el.classList.add(this.className)\n\t\t}\n\t}\n\n\t/**\n\t * Set attributes from a hash on this view's element.  Exposed for\n\t * subclasses using an alternative DOM manipulation API.\n\t * @param {object} attributes \n\t */\n\t_setAttributes(attributes) {\n\t\tif (this.attributes) {\n\t\t\tfor (let [key, value] of Object.entries(this.attributes)) {\n\t\t\t\tthis.el.setAttribute(key, value)\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * Set callbacks, where `this.events` is a hash of\n\t * *{\"event selector\": \"callback\"}*\n\t *\n\t *    {\n\t *       'mousedown .title':  'edit',\n\t *       'click .button':     'save',\n\t *       'click .open':       function(e) { ... },\n\t *       'keydown .':     \t  'handleKey'\n\t *    }\n\t * pairs. Callbacks will be bound to the view, with `this` set properly.\n\t * \n\t * \n\t * Note that the selector `.` will match the root element and can be used\n\t * as a final chance to handle events or for events like an escape key\n\t * which are essentially global to the widget.\n\t * \n\t */\n\t_addListeners() {\n\t\tthis.eventTriggers = Object.entries(this.events).map(eventEntryMapper)\n\t\tlet eventNames = extractEventNames(this.eventTriggers)\t\t\n\n\t\tfor(let eventName of eventNames) {\n\t\t\tthis.el.addEventListener(eventName, this._eventHandler.bind(this))\n\t\t}\n\t}\n\t\n\t/**\n\t * Get the elements from the view which match the selector\n\t * @param {string} selector A css selector. `.` will select the root element\n\t * @returns An array of elements\n\t */\n\t_getCandidates(selector) {\n\t\tif(selector === '.') {\n\t\t\treturn [this.el]\n\t\t}\n\t\treturn Array.from(this.el.querySelectorAll(selector))\n\t}\n\t\n\t/**\n\t * Handles all events for all elements within the view. It attempts to find a\n\t * trigger matching the event and then process it. It will match and invoke\n\t * only one trigger.\n\t * @param {Event} evt \n\t */\n\t_eventHandler(evt) {\n\t\tfor(let trigger of this.eventTriggers) {\n\t\t\tif(evt.type == trigger.event) {\n\t\t\t\tlet candidates = this._getCandidates(trigger.selector)\n\t\t\t\tlet found = null\n\t\t\t\tfor(let candidate of candidates) {\n\t\t\t\t\tif(candidate === evt.target || candidate.contains(evt.target)) {\n\t\t\t\t\t\tfound = candidate\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(found) {\n\t\t\t\t\tif(typeof trigger.handler === 'string') {\n\t\t\t\t\t\tthis[trigger.handler].call(this, evt, found)\n\t\t\t\t\t}\t\n\t\t\t\t\telse if(typeof trigger.handler === 'function') {\n\t\t\t\t\t\ttrigger.handler.call(this, evt, found)\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","/**\n * Generates a random string id in the browser. Will probably not work\n * on the server.\n * @returns A base64 web url safe string\n */\nexport default function generateId() {\n\tlet array = new Uint8Array(32)\n\twindow.crypto.getRandomValues(array)\n\tlet value = btoa(array)\n\tvalue = value.replace(/\\//g, \"_\").replace(/\\+/g, \"-\").replace(/=+$/, \"\")\n\treturn value\n}","export default function extractEventNames(eventTriggers) {\n\tlet eventNames = Array.from(eventTriggers.reduce((acc, trigger) => {\n\t\tacc.add(trigger.event)\n\t\treturn acc\n\t}, new Set()))\n\treturn eventNames\n}","\nexport default class Streamish {\n\tconstructor() {\n\t\tthis.handles = {}\n\t}\n\n\ton(evt, handle) {\n\t\tlet handles = this.handles[evt]\n\t\tif (!handles) {\n\t\t\thandles = this.handles[evt] = []\n\t\t}\n\t\thandles.push(handle)\n\t\treturn this\n\t}\n\n\temit(evt, ...args) {\n\t\tif (evt in this.handles) {\n\t\t\tfor (let handle of this.handles[evt]) {\n\t\t\t\thandle.apply(this, args)\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Removes the specified listener from the listener array for the event named eventName.\n\t * @param {string} eventName The event type name\n\t * @param {function} listener The listener function\n\t */\n\tremoveListener(eventName, listener) {\n\t\tif (eventName in this.handles) {\n\t\t\tthis.handles[eventName] = this.handles[eventName].filter(func => {\n\t\t\t\treturn func !== listener\n\t\t\t})\n\t\t}\n\t}\n}","import Streamish from \"./streamish.mjs\"\n\n/**\n * Add this most basic of the EventEmitter functions (on, emit, removeListener) to the browser's\n * EventTarget functionality.\n * \n * The eventEmitter.emit() method allows an arbitrary set of arguments to be passed to the listener \n * functions. Keep in mind that when an ordinary listener function is called, the standard this \n * keyword is intentionally set to reference the EventEmitter instance to which the listener is attached.\n */\nlet base = typeof EventTarget === 'undefined' ? Streamish : EventTarget\nexport default class EventEmitter extends base {\n\tconstructor(target) {\n\t\tsuper(target)\n\t\tif(target) {\n\t\t\tthis.innerEventTarget = target\n\t\t}\n\t\telse {\n\t\t\tthis.innerEventTarget = this\n\t\t}\n\t}\n\t/**\n\t * Adds the listener function to the end of the listeners array for the event named eventName. No checks \n\t * are made to see if the listener has already been added. Multiple calls passing the same combination \n\t * of eventName and listener will result in the listener being added, and called, multiple times.\n\t * @param {string} eventName The event type name\n\t * @param {*} listener The listener function where has arbitrary arguments\n\t */\n\ton(eventName, listener) {\n\t\tif(this.innerEventTarget.addEventListener) {\n\t\t\tlet nativeListener = (event) => {\n\t\t\t\tlistener.apply(this, event.detail)\n\t\t\t}\n\t\t\tlistener.nativeListener = nativeListener\n\t\t\tthis.innerEventTarget.addEventListener(eventName, nativeListener)\n\t\t}\n\t\telse {\n\t\t\tsuper.on(eventName, listener)\n\t\t}\n\t\treturn this\n\t}\n\n\t/**\n\t * Synchronously calls each of the listeners registered for the event named eventName, in the order \n\t * they were registered, passing the supplied arguments to each.\n\t * \n\t * @param {string} eventName The event type name\n\t * @param  {...any} args \n\t */\n\temit(eventName, ...args) {\n\t\tif(this.innerEventTarget.dispatchEvent) {\n\t\t\tthis.innerEventTarget.dispatchEvent(this._makeEvent(eventName, args))\n\t\t}\n\t\telse {\n\t\t\tsuper.emit(eventName, ...args)\n\t\t}\n\t\treturn this\n\t}\n\n\t/**\n\t * Removes the specified listener from the listener array for the event named eventName.\n\t * @param {string} eventName The event type name\n\t * @param {function} listener The listener function\n\t */\n\tremoveListener(eventName, listener) {\n\t\tif(this.innerEventTarget.removeEventListener) {\n\t\t\tlistener = listener.nativeListener || listener\n\t\t\tthis.innerEventTarget.removeEventListener(eventName, listener)\n\t\t}\n\t\telse {\n\t\t\tsuper.removeListener(eventName, listener)\n\t\t}\n\t\treturn this\n\t}\n\t\n\t_makeEvent(eventName, args) {\n\t\tif(typeof CustomEvent === 'function') {\n\t\t\treturn new CustomEvent(eventName, {\n\t\t\t\tdetail: args\n\t\t\t})\n\t\t}\n\t\telse {\n\t\t\tlet evt = new Event(eventName)\n\t\t\tevt.detail = args\n\t\t\treturn evt\n\t\t}\n\t}\n}","let Emitter\nimport Streamish from \"./streamish.mjs\"\nimport EventEmitter from \"./event-emitter.mjs\"\n\nif (typeof EventTarget !== 'undefined') {\n\tEmitter = EventEmitter\n}\nelse {\n\tEmitter = Streamish\n}\n\n\nexport default Emitter","import { View } from '@webhandle/backbone-view'\nimport Emitter from '@webhandle/minimal-browser-event-emitter'\nimport DataItemWorker from './data-item-worker.mjs'\n\nlet dataItemWorker = new DataItemWorker()\n\nexport default class ListView extends View {\n\n\t/**\n\t * Setup the event listners and default objects.\n\t * @param {Object} options \n\t */\n\tpreinitialize(options = {}) {\n\t\tthis.desktopHandleSelector = options.desktopHandleSelector\n\t\tthis.mobileHandleSelector = options.mobileHandleSelector || '.handle'\n\t\tthis.events = Object.assign({}, {\n\t\t\t'drop .': 'handleDrop'\n\t\t\t, 'dragend .': 'handleDragEnd'\n\t\t\t, 'dragleave .': 'handleDragLeave'\n\t\t\t, 'dragover .': 'handleDragover'\n\t\t\t, 'dragenter .': 'dragEnter'\n\t\t\t, 'dragover *': 'dragEnterCell'\n\t\t\t, 'dragstart *': 'dragStart'\n\t\t\t, ['touchstart ' + this.mobileHandleSelector]: 'touchDrag'\n\t\t\t, ['touchmove ' + this.mobileHandleSelector]: 'touchMove'\n\t\t\t, ['touchend ' + this.mobileHandleSelector]: 'touchEnd'\n\t\t\t, ['touchcancel ' + this.mobileHandleSelector]: 'touchCancel'\n\t\t}, options.events)\n\t\tthis.placeholderName = options.placeholderName || 'New Item'\n\t\toptions.events = this.events\n\t\tif (!this.emitter) {\n\t\t\tthis.emitter = new Emitter()\n\t\t}\n\t\tthis.overscrollCaptures = {}\n\t}\n\n\t/**\n\t * Returns true if a file is being dragged into the list.\n\t * @param {Event} evt \n\t * @returns \n\t */\n\tisFileTypeDrag(evt) {\n\t\tif (evt.dataTransfer && evt.dataTransfer.item && evt.dataTransfer.item.length > 0) {\n\t\t\tif (evt.dataTransfer.items[0].kind === 'file') {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\tif (evt.dataTransfer && evt.dataTransfer.types) {\n\t\t\tfor (let type of evt.dataTransfer.types) {\n\t\t\t\tif (type.toLowerCase() == 'files') {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false\n\t}\n\n\t/**\n\t * Looks to see if there's a resource label and we should therefore consider this an\n\t * external resource object that's being dragged into the list.\n\t * @param {Event} evt \n\t * @returns \n\t */\n\tisResourceTypeDrag(evt) {\n\t\treturn !!this.extractLabel(evt)\n\t}\n\n\t/**\n\t * Watches for entry of dragging into a cell so we can tell of the user is still\n\t * performing a drag operation.\n\t * @param {Event} evt \n\t * @param {Element} selected \n\t */\n\tdragEnterCell(evt, selected) {\n\t\tthis.canCancel = false\n\t}\n\n\t/**\n\t * Watch for the end of dragging for one of the existing cells. This is the cleanup\n\t * for the case where a user is dragging and then presses escape.\n\t * @param {Event} evt \n\t * @param {Element} selected \n\t */\n\thandleDragEnd(evt, selected) {\n\t\tthis.cleanupDrag()\n\t}\n\n\t/**\n\t * Watches for the mouse leaving the list area. The spec has no good way to tell if the user\n\t * has stopped dragging within our control area, so here we're doing a little dance to watch\n\t * when the user leaves any of the top level elements and then perform a cancel if we don't\n\t * see another drag event within a few milliseconds.\n\t * \n\t * This does sometimes lead to false positives, but that's generally okay since the code just\n\t * interprets the next drag event as if the user just started their drag, so it recovers \n\t * fairly well.\n\t * @param {Event} evt \n\t * @param {Element} selected \n\t */\n\thandleDragLeave(evt, selected) {\n\t\tif (this.externalDrag) {\n\t\t\tif (evt.target == this.el || this.getCells().includes(evt.target)) {\n\t\t\t\t// so we're leaving the whole list. If we don't immediately enter someplace else\n\t\t\t\t// then we should interpret this as a cancel\n\t\t\t\t// In this case, \"the whole list\" is one of the cells or the container\n\t\t\t\tthis.canCancel = true\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tif (this.canCancel) {\n\t\t\t\t\t\tthis.cleanupDrag()\n\t\t\t\t\t}\n\t\t\t\t}, 20)\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns true if this is a type of object from outside the list that can be added\n\t * to the list. By default it allows files and uri-list types. To turn off the abilty\n\t * to drag other items into the list, just override to return false.\n\t * @param {Event} evt \n\t * @returns \n\t */\n\tshouldInsertCellForExternalDrag(evt) {\n\t\treturn this.isFileTypeDrag(evt) || this.isResourceTypeDrag(evt)\n\t}\n\n\n\t/**\n\t * This is the mobile/touch equivalent of dragStart\n\t * @param {Event} evt \n\t * @param {Element} selected \n\t */\n\ttouchDrag(evt, selected) {\n\t\tthis.captureOverscroll('html')\n\t\tthis.captureOverscroll('body')\n\t\tthis.dragStart(evt, selected)\n\t}\n\n\t/**\n\t * Handle the user touch dragging an item.\n\t * @param {Event} evt \n\t * @param {Element} selected \n\t */\n\ttouchMove(evt, selected) {\n\t\tlet top = this.boxTop()\n\t\tlet pos = Math.max(0, evt.touches[0].pageY) - top\n\t\tthis.positionOnDrag(pos)\n\t}\n\n\t/**\n\t * This is essentially a mobile/touch drop\n\t * @param {Event} evt \n\t * @param {Element} selected \n\t */\n\ttouchEnd(evt, selected) {\n\t\tthis.handleDrop(evt, selected)\n\t}\n\n\t/**\n\t * Cleanup after a mobile drag\n\t * @param {Event} evt \n\t * @param {Element} selected \n\t */\n\ttouchCancel(evt, selected) {\n\t\tthis.cleanupDrag()\n\t}\n\n\t/**\n\t * Listens for the element being dragged. The spec seems to indicate that this is\n\t * fired on mobile as well, but in practice is seems to only get fired on \n\t * desktop.\n\t * @param {Event} evt \n\t * @param {Element} selected \n\t */\n\tdragStart(evt, selected) {\n\t\tthis.dragging = this.getCellFromChild(selected)\n\t\tthis.dragging.classList.add('dragging')\n\t\tif (evt.dataTransfer) {\n\t\t\tevt.dataTransfer.setDragImage(document.createElement('div'), 0, 0)\n\t\t}\n\t}\n\n\t/**\n\t * Extracts a placeholder label from the data transfer types. The label name is\n\t * part of the type name. So, a type of `data:text/label,awesome` would indicate\n\t * that the placeholder is supposed to be `awesome`.\n\t * @param {Event} evt \n\t * @returns \n\t */\n\textractLabel(evt) {\n\t\tlet labelPrefix = 'data:text/label,'\n\t\tfor (let type of evt.dataTransfer.types) {\n\t\t\tif (type.indexOf(labelPrefix) == 0) {\n\t\t\t\treturn type.substring(labelPrefix.length)\n\t\t\t}\n\t\t}\n\n\t\treturn null\n\t}\n\n\t/**\n\t * Restores the elements previous overscroll behavior (see captureOverscroll for why we need\n\t * this)\n\t * @param {string} elName \n\t */\n\trestoreOverscroll(elName) {\n\t\tif (elName in this.overscrollCaptures) {\n\t\t\tdocument.querySelector(elName).style['overscroll-behavior'] = this.overscrollCaptures[elName]\n\t\t\tdelete this.overscrollCaptures[elName]\n\t\t}\n\t}\n\n\t/**\n\t * Used for mobile to get the present value of what happens when the user drags their finger\n\t * farther than the screen can scroll. By default what happens is a page reload. That won't \n\t * be what we want if a user is dragging a list item, so we have to capture that behavior and\n\t * change it so that nothing happens to the page.\n\t * @param {string} elName \n\t */\n\tcaptureOverscroll(elName) {\n\t\tlet el = document.querySelector(elName)\n\t\tthis.overscrollCaptures[elName] = el.style['overscroll-behavior']\n\t\tel.style['overscroll-behavior'] = 'none'\n\t}\n\n\t/**\n\t * Utility function to create a dom node based on html\n\t * @param {string} html \n\t * @returns \n\t */\n\t_makeElementFromHTML(html) {\n\t\tlet div = document.createElement('div')\n\t\tdiv.innerHTML = html\n\t\tlet child = div.children[0]\n\t\treturn child\n\t}\n\n\n\t/**\n\t * Creates markup for the external drag event placeholder cell. Attempts\n\t * to determine a reasonable label.\n\t * @param {Event} evt \n\t * @returns \n\t */\n\tcreateExternalDragPlaceholderHTML(evt) {\n\t\tlet placeholder = this.extractLabel(evt) || this.placeholderName\n\t\tlet html = `<div class=\"cell\">\n\t\t\t<span class=\"handle\">↕</span>\n\t\t\t${placeholder}\n\t\t</div>`\n\t\treturn html\n\n\t}\n\n\t/**\n\t * Creates a placeholder cell for a drag event where the source is an\n\t * external object like a file or something else on the page.\n\t * @param {Event} evt \n\t */\n\tcreateExternalDragPlaceholderCell(evt) {\n\t\tlet html = this.createExternalDragPlaceholderHTML(evt)\n\t\tlet cell = this._makeElementFromHTML(html)\n\t\tcell.setAttribute('draggable', true)\n\t\tthis.addCell(cell)\n\t\tthis.dragStart(evt, cell)\n\t}\n\n\tdragEnter(evt, selected) {\n\t\tif (!this.dragging && this.shouldInsertCellForExternalDrag(evt)) {\n\t\t\t// If we're not already doing a drag operation, we need to start one\n\t\t\t// We create a placeholder for this event and then move it up and down\n\t\t\t// like a pre-existing cell. \n\t\t\t// NOTE: We do not have much information about the contents of the\n\t\t\t// drag until the drop event occurs. This placeholder may have to be\n\t\t\t// somewhat generic.\n\t\t\tthis.externalDrag = true\n\t\t\tthis.createExternalDragPlaceholderCell(evt)\n\t\t}\n\t}\n\n\t/**\n\t * Watch for movement of something being dragged\n\t * @param {Event} evt \n\t * @param {Element} selected \n\t */\n\thandleDragover(evt, selected) {\n\t\tevt.preventDefault()\n\t\tthis.canCancel = false\n\t\tlet top = this.boxTop()\n\t\tlet pos = evt.y - top\n\n\t\tif (this.dragging) {\n\t\t\tif (evt.dataTransfer) {\n\t\t\t\tevt.dataTransfer.dropEffect = 'move'\n\t\t\t}\n\t\t\tthis.positionOnDrag(pos)\n\t\t}\n\t\telse {\n\t\t\tif (evt.dataTransfer) {\n\t\t\t\tevt.dataTransfer.dropEffect = 'copy'\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Creates permanent cells for files dropped into the list\n\t * @param {array[FileEntry|File]} files \n\t * @returns an array of Elements\n\t */\n\tcreateCellsForFiles(files) {\n\t\tlet cells = files.map(file => {\n\t\t\tlet html = `<div class=\"cell\">\n\t\t\t\t<span class=\"handle\">↕</span>\n\t\t\t\t${file.name}\n\t\t\t</div>`\n\t\t\tlet el = this._makeElementFromHTML(html)\n\t\t\tel.data = file\n\t\t\treturn el\n\t\t})\n\t\treturn cells\n\t}\n\n\t/**\n\t * Creates permanent cells for resource objects dropped into the list\n\t * @param {array[string]} uriList \n\t * @returns an array of Elements\n\t */\n\tcreateCellsForUriList(uriList) {\n\t\tif (!Array.isArray(uriList)) {\n\t\t\turiList = [uriList]\n\t\t}\n\t\tlet cells = uriList.map(uri => {\n\t\t\tlet html = `<div class=\"cell\">\n\t\t\t\t<span class=\"handle\">↕</span>\n\t\t\t\t${uri}\n\t\t\t</div>`\n\t\t\tlet el = this._makeElementFromHTML(html)\n\t\t\tel.data = uri\n\t\t\treturn el\n\t\t})\n\t\treturn cells\n\t}\n\n\t/**\n\t * Creates permanent cells for drops of unknown types.\n\t * @param {Event} evt \n\t * @returns An array of elements\n\t */\n\tcreateCellsForUnknownType(evt) {\n\t\treturn []\n\t}\n\n\t/**\n\t * Creates permanent cells for external items dropped into the list,\n\t * emits events, and does cleaup\n\t * @param {Event} evt \n\t * @param {Element} selected \n\t */\n\thandleDrop(evt, selected) {\n\t\tevt.preventDefault()\n\t\t\n\t\t// Sometimes the placeholder gets cleaned up before the insertion of the new nodes\n\t\t// happens. Let's capture the following element just in case we need it.\n\t\tlet afterDragElement\n\t\tif(this.dragging) {\n\t\t\tafterDragElement = this.dragging.nextElementSibling\n\t\t}\n\n\t\tlet p = new Promise(async (resolve, reject) => {\n\t\t\tlet uriList\n\t\t\tif (evt.dataTransfer) {\n\t\t\t\turiList = evt.dataTransfer.getData('text/uri-list')\n\t\t\t}\n\n\t\t\tif (this.externalDrag || uriList) {\n\t\t\t\t// if a link is dropped, there's no exteralDrag object, just a drop object\n\n\t\t\t\tlet changes = []\n\t\t\t\tlet files = await dataItemWorker.getFileEntriesFromEvent(evt, {\n\t\t\t\t\tkeepDirectories: false\n\t\t\t\t\t, recursive: true\n\t\t\t\t})\n\t\t\t\tlet cells = []\n\t\t\t\tif (files && files.length > 0) {\n\t\t\t\t\tcells = this.createCellsForFiles(files)\n\t\t\t\t\tfor (let count = 0; count < cells.length; count++) {\n\t\t\t\t\t\tlet cell = cells[count]\n\t\t\t\t\t\tif (!cell.file) {\n\t\t\t\t\t\t\tcell.file = files[count]\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (uriList) {\n\t\t\t\t\tif (typeof uriList == 'string') {\n\t\t\t\t\t\t// Acording to the spec, this should be a list with one uri on every line\n\t\t\t\t\t\t// In practice, it seems like the browser is eating the return characters\n\t\t\t\t\t\t// In my tests, I'm passing multiple uris as comma separated. I'm handling\n\t\t\t\t\t\t// both cases here.\n\t\t\t\t\t\tlet parts = [uriList]\n\t\t\t\t\t\tfor (let sep of ['\\r\\n', '\\n', ',']) {\n\t\t\t\t\t\t\tlet newParts = []\n\t\t\t\t\t\t\tfor (let part of parts) {\n\t\t\t\t\t\t\t\tnewParts.push(...part.split(sep))\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tparts = newParts\n\t\t\t\t\t\t}\n\t\t\t\t\t\turiList = parts\n\t\t\t\t\t}\n\t\t\t\t\tcells = this.createCellsForUriList(uriList)\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcells = this.createCellsForUnknownType(evt)\n\t\t\t\t}\n\n\t\t\t\tfor (let cell of cells) {\n\t\t\t\t\tcell.setAttribute('draggable', true)\n\t\t\t\t\tthis.addCell(cell, {\n\t\t\t\t\t\tbefore: this.dragging || afterDragElement\n\t\t\t\t\t})\n\t\t\t\t\tchanges.push({\n\t\t\t\t\t\tcell: cell\n\t\t\t\t\t\t, file: cell.file\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\tif (this.dragging) {\n\t\t\t\t\tthis.dragging.remove()\n\t\t\t\t}\n\t\t\t\tthis.emitter.emit('list-change', {\n\t\t\t\t\ttype: 'drop'\n\t\t\t\t\t, cells: cells\n\t\t\t\t\t, files: files\n\t\t\t\t\t, changes: changes\n\t\t\t\t\t, event: evt\n\t\t\t\t})\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.emitter.emit('list-change', {\n\t\t\t\t\ttype: 'reorder'\n\t\t\t\t\t, cells: [this.dragging]\n\t\t\t\t})\n\t\t\t}\n\n\t\t})\n\t\tthis.cleanupDrag()\n\t\treturn p\n\t}\n\n\t/**\n\t * Adds a new item to the list, last item by default \n\t * @param {string|Element} cell The item to add \n\t * @param {*} [options]\n\t * @param {boolean} options.first If true inserted at the start of the list\n\t * @param {boolean} options.last If true inserted at the end of the list\n\t * @param {Element} options.after Insert after this item \n\t * @param {Element} options.before Insert before this item\n\t * @param {*} options.data Data to be set on the element\n\t */\n\taddCell(cell, options = {}) {\n\t\tif (typeof cell === 'string') {\n\t\t\tcell = this._makeElementFromHTML(cell)\n\t\t}\n\n\t\tif (options.data) {\n\t\t\tcell.data = options.data\n\t\t}\n\n\t\tif (options.first) {\n\t\t\tthis.el.insertAdjacentElement('afterbegin', cell)\n\t\t}\n\t\telse if (options.before) {\n\t\t\tthis.el.insertBefore(cell, options.before)\n\t\t}\n\t\telse if (options.after) {\n\t\t\toptions.after.after(cell)\n\t\t}\n\t\telse {\n\t\t\tthis.el.insertAdjacentElement('beforeend', cell)\n\t\t}\n\t\treturn cell\n\t}\n\n\t/**\n\t * \n\t * @param {int} pos position of pointer relative to the top of the box\n\t */\n\tpositionOnDrag(pos) {\n\t\tlet over = this.findOver(pos)\n\t\tthis.addCell(this.dragging, {\n\t\t\tbefore: over\n\t\t})\n\t}\n\n\t/**\n\t * Gets the top level objects of the list.\n\t * @returns \n\t */\n\tgetCells() {\n\t\treturn [...this.el.children]\n\t}\n\n\t/**\n\t * Cleanup after a drag event by deleting any placeholder objects\n\t * and restoring the browser to its pre-drag settings\n\t */\n\tcleanupDrag() {\n\t\tif (this.dragging && this.externalDrag) {\n\t\t\tthis.dragging.remove()\n\t\t}\n\n\t\tdelete this.dragging\n\t\tdelete this.externalDrag\n\t\tthis.getCells().forEach(cell => {\n\t\t\tcell.classList.remove('dragging')\n\t\t})\n\t\tthis.restoreOverscroll('html')\n\t\tthis.restoreOverscroll('body')\n\t}\n\n\t/**\n\t * Determine which cell the pointer/finger is currently over.\n\t * @param {Object} pos \n\t * @returns \n\t */\n\tfindOver(pos) {\n\t\tlet locations = this.findLocations()\n\t\tfor (let loc of locations) {\n\t\t\tif (pos >= loc.top && pos <= loc.bottom) {\n\t\t\t\treturn loc.cell\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Gets the top of the list box\n\t * @returns \n\t */\n\tboxTop() {\n\t\tlet boxRect = this.el.getBoundingClientRect()\n\t\tlet top = boxRect.top\n\t\treturn top\n\t}\n\n\n\t/**\n\t * Sets up the cells to be draggable and makes the mobile touch handles ready for drag.\n\t */\n\trender() {\n\t\tif (this.desktopHandleSelector) {\n\t\t\tthis.el.querySelectorAll(this.desktopHandleSelector).forEach(handle => {\n\t\t\t\thandle.setAttribute(\"draggable\", true)\n\t\t\t})\n\t\t}\n\t\telse {\n\t\t\tthis.getCells().forEach(cell => {\n\t\t\t\tcell.setAttribute(\"draggable\", true)\n\t\t\t})\n\t\t}\n\t\tif (this.mobileHandleSelector) {\n\t\t\tthis.el.querySelectorAll(this.mobileHandleSelector).forEach(handle => {\n\t\t\t\thandle.style['touch-action'] = 'none'\n\t\t\t})\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @returns The relative locations of the cells in the list\n\t */\n\tfindLocations() {\n\t\tlet top = this.boxTop()\n\n\t\tlet locations = []\n\t\tthis.getCells().forEach(cell => {\n\t\t\tlet rect = cell.getBoundingClientRect()\n\t\t\tlocations.push({\n\t\t\t\ttop: rect.top - top\n\t\t\t\t, bottom: rect.bottom - top\n\t\t\t\t, cell: cell\n\t\t\t})\n\t\t})\n\t\treturn locations\n\t}\n\n\t/**\n\t * Give a node for the cell or a descendent of a cell, returns the node\n\t * for the cell.\n\t * @param {Node} child \n\t * @returns \n\t */\n\tgetCellFromChild(child) {\n\t\tif (child.parentElement == this.el) {\n\t\t\treturn child\n\t\t}\n\t\tif (!child) {\n\t\t\treturn null\n\t\t}\n\t\treturn this.getCellFromChild(child.parentElement)\n\t}\n}\n\n\n","\nexport default class DataItemWorker {\n\n\tasync getFileFromEntry(entry) {\n\t\tlet p = new Promise(async (resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tif (entry.file) {\n\t\t\t\t\tentry.file(file => {\n\t\t\t\t\t\tfile.entry = entry\n\t\t\t\t\t\tresolve(file)\n\t\t\t\t\t}, (err) => {\n\t\t\t\t\t\tconsole.error(err)\n\t\t\t\t\t\tresolve(null)\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tresolve(null)\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\tconsole.error(e)\n\t\t\t\tresolve(null)\n\t\t\t}\n\t\t})\n\t\treturn p\n\t}\n\n\tasync readDirectoryEntries(entry) {\n\t\tlet p = new Promise((resolve, reject) => {\n\t\t\tlet dirReader = entry.createReader()\n\t\t\tlet result = []\n\t\t\tlet readThem = () => {\n\t\t\t\tdirReader.readEntries(async (entries) => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif(entries && entries.length > 0) {\n\t\t\t\t\t\t\tfor (let entry of entries) {\n\t\t\t\t\t\t\t\tresult.push(entry)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treadThem()\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tresolve(result)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (e) {\n\t\t\t\t\t\tconsole.error(e)\n\t\t\t\t\t\tresolve(result)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t\treadThem()\n\t\t})\n\t\treturn p\n\t}\n\n\t/**\n\t * \n\t * Takes a list of DataTransferItems and resolves them to FileEntry objects.\n\t * \n\t * Note, you can get a real File object by calling `getFileFromEntry`\n\t * @param {array[DataTransferItem|File|FileEntry|DirectoryEntry]} entries \n\t * @param {*} [options]\n\t * @returns \n\t */\n\tasync expandEntries(entries, options) {\n\t\toptions = Object.assign({\n\t\t\tkeepDirectories: false\n\t\t\t, recursive: true\n\t\t}, options)\n\t\tlet expanded = []\n\t\tlet target = [...entries]\t\n\t\t\n\t\twhile(target.length > 0) {\n\t\t\t\n\t\t\t// You MUST process all of the DataTransferItems first. If you do a directory read\n\t\t\t// it will blank out the information on those items.\n\t\t\tlet item = target.shift()\n\t\t\t\n\t\t\tif(item instanceof File) {\n\t\t\t\texpanded.push(item)\n\t\t\t}\n\t\t\telse if(item.isFile === true && item.isDirectory === false) {\n\t\t\t\texpanded.push(item)\n\t\t\t}\n\t\t\telse if(item.isFile === false && item.isDirectory === true) {\n\t\t\t\tlet dirEntries = await this.readDirectoryEntries(item)\n\t\t\t\tif(options.recursive) {\n\t\t\t\t\ttarget.push(...dirEntries)\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(!options.keepDirectories) {\n\t\t\t\t\t\tdirEntries = dirEntries.filter(item => item.isFile)\n\t\t\t\t\t}\n\t\t\t\t\texpanded.push(...dirEntries)\n\t\t\t\t}\n\t\t\t\tif(options.keepDirectories) {\n\t\t\t\t\texpanded.push(item)\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (item.kind === \"file\") {\n\t\t\t\tif (item.webkitGetAsEntry) {\n\t\t\t\t\tlet entry = item.webkitGetAsEntry()\n\t\t\t\t\tif (entry) {\n\t\t\t\t\t\ttarget.push(entry)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(item.getAsFile) {\n\t\t\t\t\ttarget.push(item.getAsFile())\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\texpanded = expanded.filter(item => !!item)\n\t\treturn expanded\n\t}\n\n\t/**\n\t * A utility function to extract the file entries from a file drop event.\n\t * @param {Event} evt \n\t * @returns \n\t */\n\tasync getFileEntriesFromEvent(evt, options) {\n\t\tlet entries = []\n\t\t// items is the new interface we should use if that's available\n\t\tif (evt.dataTransfer.items) {\n\t\t\tentries.push(...evt.dataTransfer.items)\n\t\t} \n\t\telse if(evt.dataTransfer.files) {\n\t\t\tentries.push(...evt.dataTransfer.files)\n\t\t}\n\t\tlet result = await this.expandEntries(entries, options)\n\t\treturn result.filter(item => !!item)\n\t}\n\n\n}"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","eventEntryMapper","value","parts","trim","split","event","shift","selector","join","handler","defaultOptions","tagName","events","View","constructor","options","this","id","array","Uint8Array","window","crypto","getRandomValues","btoa","replace","generateId","assign","preinitialize","apply","arguments","_ensureElement","initialize","render","remove","el","parentElement","removeChild","appendTo","container","appendChild","replaceContentsOf","innerHTML","setElement","_addListeners","_createElement","name","document","createElement","setAttribute","view","_setAttributes","className","classList","add","attributes","entries","eventTriggers","map","eventNames","Array","from","reduce","acc","trigger","Set","eventName","addEventListener","_eventHandler","bind","_getCandidates","querySelectorAll","evt","type","candidates","found","candidate","target","contains","Streamish","handles","on","handle","push","emit","args","removeListener","listener","filter","func","Emitter","base","EventTarget","super","innerEventTarget","nativeListener","detail","dispatchEvent","_makeEvent","removeEventListener","CustomEvent","Event","dataItemWorker","getFileFromEntry","entry","Promise","async","resolve","reject","file","err","console","error","e","readDirectoryEntries","dirReader","createReader","result","readThem","readEntries","length","expandEntries","keepDirectories","recursive","expanded","item","File","isFile","isDirectory","dirEntries","kind","webkitGetAsEntry","getAsFile","getFileEntriesFromEvent","dataTransfer","items","files","ListView","desktopHandleSelector","mobileHandleSelector","placeholderName","emitter","overscrollCaptures","isFileTypeDrag","types","toLowerCase","isResourceTypeDrag","extractLabel","dragEnterCell","selected","canCancel","handleDragEnd","cleanupDrag","handleDragLeave","externalDrag","getCells","includes","setTimeout","shouldInsertCellForExternalDrag","touchDrag","captureOverscroll","dragStart","touchMove","top","boxTop","pos","Math","max","touches","pageY","positionOnDrag","touchEnd","handleDrop","touchCancel","dragging","getCellFromChild","setDragImage","indexOf","substring","labelPrefix","restoreOverscroll","elName","querySelector","style","_makeElementFromHTML","html","div","children","createExternalDragPlaceholderHTML","createExternalDragPlaceholderCell","cell","addCell","dragEnter","handleDragover","preventDefault","y","dropEffect","createCellsForFiles","data","createCellsForUriList","uriList","isArray","uri","createCellsForUnknownType","afterDragElement","nextElementSibling","p","getData","changes","cells","count","sep","newParts","part","before","first","insertAdjacentElement","insertBefore","after","over","findOver","forEach","locations","findLocations","loc","bottom","getBoundingClientRect","rect","child"],"sourceRoot":""}